# Offers API - Spring Boot

## Description

This project aims to provide a REST API for managing product offers based on priorities and deadlines.

## Tools & Technologies Used

- **Spring Boot**: A framework for building stand-alone, production-grade Spring-based applications.
- **JPA (Java Persistence API)**: For database interaction and ORM (Object-Relational Mapping).
- **Lombok**: Used to reduce boilerplate code (generates getters, setters, `toString()`, `equals()`, and `hashCode()`).
- **Spring Data JPA**: To simplify database operations and integrate JPA with Spring.
- **Maven**: Dependency management and build tool.
- **H2**: An in-memory database used for development and testing.
- **MapStruct**: A code generator that simplifies the implementation of mappings between Java bean types based on a convention over configuration approach.
- **Mockito**: A mocking framework for unit tests.
- **JUnit 5**: A testing framework for Java.
- **BDD (Behavior-Driven Development)**: Using Gherkin format for unit tests.
- **Criteria API JPA**: A Java API used to create queries for entities stored in a relational database in a type-safe manner.

## Setup & Installation

### Prerequisites

- JDK 17 or later
- Maven (for building and running the project)

### Clone the repository

```bash
git clone git@github.com:DanielLincangoGH/prueba-tecnica-01.git
```
### Build de project

```bash
mvn clean install
```

### Run the application

```bash 
mvn spring-boot:run
``` 

### Run Unit and Integration Test

```bash 
nvm test
```

### Generate Unit and Integration Test Report

```bash 
mvn surefire-report:report
xdg-open target/reports/surefire.html
```
## Project Architecture

### Hexagonal Architecture (Ports and Adapters) with the following layers:

- **Application**: Contains business rules of application services.
- **Domain**: Contains the business logic and the domain model.
- **Ports**: Contains the interfaces that define the operations that can be performed.
- **Infrastructure**: Contains the database repositories and the implementation of the domain repositories.
- **Adapter**: Contains the implementation of the ports defined in the domain layer.

## Design Patterns

- **Repository Pattern**: Used to abstract the data access logic and provide a clean API to the rest of the application.
  - **Example**: `OfferRepository` interface in the domain layer and `OfferJpaRepository` class in the infrastructure layer.


- **Builder Pattern**: Used to create complex objects with many parameters.
  - **Example**: Using the `@Builder` annotation from Lombok to create builder methods for entities.


- **DTO (Data Transfer Object) Pattern**: Used to transfer data between the layers of the application.
  - **Example**: `Offer` class as model in the domain layer.


- **Decorator Pattern**: Used to add new functionality to an object without altering its structure.
  - **Example**: `ValidateDateRange` annotation class as custom date range validator.


- **Adapter Pattern**: Used to allow objects with incompatible interfaces to collaborate.
  - **Example**: `OfferMapper` interface in the infrastructure layer and `OfferMapperImpl` as autogenerated MapStruct class.


- **Command Query Responsibility Segregation (CQRS)**: Used to separate the read and write operations of a data store.
  - **Example**: `OfferQueryService` and `OfferCommandService` interfaces in the application layer.

## Design Patterns for Testing

- **Domain-Driven Design (DDD)**: Used to model the domain of the application in software.
   - **Example**: `Offer` and `Brand` class in the domain layer.


- **Test-Driven Development (TDD)**: Used to write tests before writing the code that is being tested.
    - **Example**: Writing unit tests for the `OfferService` class before implementing the logic.


- **Behavior-Driven Development (BDD)**: Used to write tests in a natural language that describes the behavior of the application.
   - **Example**: Writing Gherkin feature files for the `OfferService` class.

## Best Practices

- **Single Responsibility Principle (SRP)**: Used to ensure that a class has only one reason to change.
   - **Examples**: 
     - `OfferService` class for only offers operation.
     - `BrandService` class for only brand operation.
     - `OfferQueryService` class for only query operation.
     - `OfferCommandService` class for only command operation.
     - `OfferRepository` interface for only offer repository operation.
     - `BrandRepository` interface for only brand repository operation.
     - `OfferMapper` interface for only offer mapper operation.
     - `BrandMapper` interface for only brand mapper operation. 


- **Clean Code**: Used to ensure that the code is easy to read, understand, and maintain.
   - **Examples**: 
     - Using meaningful variable names and method names.
     - Writing small methods that do one thing.
     - Avoiding long parameter lists. 
     - Following the Google Checkstyle rules for code formatting.
     - Using the Lombok library to reduce boilerplate code.
     - Using the MapStruct library to simplify mappings between Java bean types.
     - Using the Criteria API JPA to create queries in a type-safe manner.
     - Using the `@Builder` annotation from Lombok to create builder methods for entities.
     - Using the `@Data` annotation from Lombok to generate getters, setters, `toString()`, `equals()`, and `hashCode()` methods.
     - Using the `@AllArgsConstructor` annotation from Lombok to generate a constructor with all arguments.
     - Using the `@NoArgsConstructor` annotation from Lombok to generate a no-args constructor.
     - Using the `@RequiredArgsConstructor` annotation from Lombok to generate a constructor with required arguments.


## IntelliJ IDEA Setup

1. **Lombok**: Ensure that the Lombok plugin is installed and enabled in your IDE.
   - For IntelliJ IDEA: Go to `File` > `Settings` > `Plugins`, search for `Lombok`, and install it. Restart the IDE if necessary.
   - Enable annotation processing: Go to `File` > `Settings` > `Build, Execution, Deployment` > `Compiler` > `Annotation Processors` and check `Enable annotation processing`.

2. **Code Formatting**: The code formatting follows the Google Checkstyle rules. Ensure that you have the Checkstyle plugin installed in your IDE and configured to use the `google_checks.xml` file.
   - Download the configuration file from [Google Style Guide](https://github.com/google/styleguide/blob/gh-pages/intellij-java-google-style.xml).
   - For IntelliJ IDEA: Go to `File` > `Code Style` > `Java`, import the downloaded `intellij-java-google-style.xml` file, and set it as the active code style.
   - Apply the code style by clicking on `Apply`.